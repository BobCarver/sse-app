import { getSessionCompetitionsWithRubrics, saveScore } from "./db.ts";
import { dlog } from "./main.ts";
import type { ClientStatusMessage, ServerToClientMessage } from "./protocol.ts";
import { resolveTag, waitForTag } from "./resolveTag.ts";
import { type Competition, SSEClient } from "./types.ts";

// ============================================================================
// SESSION
// ============================================================================

const timeOut = Number(Deno.env.get("JUDGE_SCORE_TIMEOUT_MS") || 30000);

export class Session {
  competitions: Competition[] = [];
  clients: Map<number, SSEClient | undefined> = new Map();
  running: boolean = false;

  // Track current state for recovery
  private currentCompetition: Competition | null = null;
  private currentPosition: number = -1;
  private currentPhase: "idle" | "performing" | "scoring" = "idle";
  private submittedScores: Set<string> = new Set(); // "competitionId:position:judgeId"

  constructor(public id: number) {}

  isRunning(): boolean {
    return this.running;
  }

  /**
   * Connect a client to this session
   * Handles registration, broadcasting status, and state recovery
   */
  connectClient(client: SSEClient): void {
    dlog("Session: connectClient", {
      sessionId: this.id,
      clientId: client.id,
      type: client.type,
    });

    // Register client
    this.clients.set(client.id, client);

    // Wake up any code waiting for this client
    resolveTag(`required:${client.id}`, undefined);

    // Tell all clients about updated roster
    this.broadcastClientStatus();

    // Handle state recovery if session is running
    this.handleClientReconnect(client).catch((err) =>
      console.error(`Reconnect recovery failed for client ${client.id}:`, err)
    );
  }

  /**
   * Handle client reconnection during an active session
   * Sends appropriate recovery messages based on current phase
   */
  async handleClientReconnect(client: SSEClient): Promise<void> {
    if (this.currentPhase === "idle") {
      // Nothing to recover
      return;
    }

    console.log(
      `Client ${client.id} (${client.type}) reconnected during phase: ${this.currentPhase}`,
    );

    // DJ reconnecting during performance - send recovery message
    if (client.type === "dj" && this.currentPhase === "performing") {
      this.sendToClient(client, {
        event: "performance_recovery",
        competition_id: this.currentCompetition!.id,
        position: this.currentPosition,
      });
    }

    // Judge reconnecting during scoring - resend enable_scoring if not submitted
    if (client.type === "judge" && this.currentPhase === "scoring") {
      const scoreKey = `${
        this.currentCompetition!.id
      }:${this.currentPosition}:${client.id}`;

      if (!this.submittedScores.has(scoreKey)) {
        console.log(`Resending enable_scoring to judge ${client.id}`);
        this.sendToClient(client, {
          event: "enable_scoring",
          competition_id: this.currentCompetition!.id,
          position: this.currentPosition,
        });
      } else {
        console.log(`Judge ${client.id} already submitted, no recovery needed`);
      }
    }

    // Scoreboards get nothing - they'll receive next update naturally
  }

  /**
   * Remove client from session
   */
  removeClient(clientId: number): void {
    dlog("Session: removeClient", { sessionId: this.id, clientId });
    this.clients.delete(clientId);
    this.broadcastClientStatus();
  }

  /**
   * Wait for all registered clients to connect
   * Used to ensure judges are present before starting competitions
   */
  async requireAllClients(): Promise<void> {
    const disconnectedClients = [];
    for (const [id, client] of this.clients.entries()) {
      if (!client) {
        disconnectedClients.push(id);
      }
    }

    if (disconnectedClients.length > 0) {
      dlog("Session: waiting for clients", { disconnectedClients });
      await Promise.all(
        disconnectedClients.map((id) => waitForTag(`required:${id}`)),
      );
      dlog("Session: all clients connected", { disconnectedClients });
    }
  }

  /**
   * Wait for specific clients to connect (by client ID)
   */
  async require(clientIds: number[]): Promise<void> {
    const missing = clientIds.filter((id) =>
      !this.clients.has(id) || !this.clients.get(id)
    );

    if (missing.length > 0) {
      dlog("Session: waiting for required clients", { missing });
      await Promise.all(
        missing.map((id) => waitForTag(`required:${id}`)),
      );
      dlog("Session: required clients connected", { missing });
    }
  }

  /**
   * Broadcast client connection status to all clients
   */
  broadcastClientStatus(): void {
    const message: ClientStatusMessage = {
      event: "client_status",
      connected_clients: Array.from(this.clients.keys()),
    };
    dlog("broadcastClientStatus", message);
    this.broadcast(message);
  }

  /**
   * Send message to a specific client
   */
  private sendToClient(
    client: SSEClient,
    message: ServerToClientMessage,
  ): void {
    try {
      const { event, ...payload } = message;
      const data = JSON.stringify(payload);
      client.controller.enqueue(`event: ${event}\ndata: ${data}\n\n`);
    } catch (error) {
      console.error(`Failed to send to client ${client.id}:`, error);
      // Mark as disconnected (will be cleaned up by SSE handler)
      this.clients.set(client.id, undefined);
    }
  }

  /**
   * Broadcast message to all connected clients
   */
  broadcast(message: ServerToClientMessage): void {
    const { event, ...payload } = message;
    const data = JSON.stringify(payload);

    console.log("broadcast ->", JSON.stringify(message));

    for (const [clientId, client] of this.clients.entries()) {
      if (client === undefined) {
        // Client is registered but disconnected, skip
        continue;
      }

      try {
        client.controller.enqueue(`event: ${event}\ndata: ${data}\n\n`);
      } catch (error) {
        console.error(`Failed to send to client ${clientId}:`, error);
        // Mark as disconnected (will be cleaned up by SSE handler)
        this.clients.set(clientId, undefined);
      }
    }
  }

  /**
   * Performance phase - DJ plays audio for competitor
   * Returns true if performance completed, false if skipped
   */
  private async performPhase(
    competition: Competition,
    position: number,
  ): Promise<boolean> {
    this.currentPhase = "performing";
    this.currentCompetition = competition;
    this.currentPosition = position;

    // Send performance start to DJ and all clients
    this.broadcast({
      event: "performance_start",
      competition_id: competition.id,
      position,
    });

    // Wait for DJ to signal completion (tag: perf:competitionId:position)
    const result = await waitForTag(
      `perf:${competition.id}:${position}`,
    );

    this.currentPhase = "idle";
    return result;
  }

  /**
   * Scoring phase - judges submit scores for competitor
   */
  private async scorePhase(competition: Competition): Promise<void> {
    this.currentPhase = "scoring";

    // Enable scoring for all judges
    this.broadcast({
      event: "enable_scoring",
      competition_id: competition.id,
      position: this.currentPosition,
    });

    // Wait for all judges to submit scores (with timeout)
    const scorePromises = competition.rubric.judges.map(async ({ id }) => {
      try {
        const submission = await waitForTag(
          `score:${competition.id}:${this.currentPosition}:${id}`,
          timeOut,
        );

        // Mark as submitted before saving
        const scoreKey = `${competition.id}:${this.currentPosition}:${id}`;
        this.submittedScores.add(scoreKey);

        // Save to database
        await saveScore(submission);

        // Broadcast to scoreboards
        this.broadcast({
          event: "score_update",
          ...submission,
        });

        return { success: true, judgeId: id };
      } catch (err) {
        console.warn(`Judge ${id} timeout or error:`, err);
        return { success: false, judgeId: id, error: err };
      }
    });

    const results = await Promise.allSettled(scorePromises);

    // Log any failures
    const failures = results.filter((r) =>
      r.status === "rejected" || (r.status === "fulfilled" && !r.value.success)
    );

    if (failures.length > 0) {
      console.warn(`${failures.length} judges failed to submit scores`);
    }

    this.currentPhase = "idle";
  }

  /**
   * Announce competition start to all clients
   */
  competitionStart(competition: Competition): void {
    this.broadcast({
      event: "competition_start",
      competition,
    });
  }

  /**
   * Main session execution loop
   * Orchestrates competitions and scoring
   */
  async runSession(): Promise<void> {
    // Prevent concurrent runs
    if (this.running) {
      throw new Error(`Session ${this.id} already running`);
    }

    // Ensure competitions are loaded
    if (!this.competitions || this.competitions.length === 0) {
      const comps = await getSessionCompetitionsWithRubrics(this.id);
      if (!comps || comps.length === 0) {
        throw new Error(`No competitions found for session ${this.id}`);
      }
      this.competitions = comps;
    }

    this.running = true;
    this.submittedScores.clear();

    console.log(
      `Starting session ${this.id} (competitions=${this.competitions.length})`,
    );

    try {
      // Ensure DJ is connected (client ID 0)
      dlog("Session: waiting for DJ (id=0)");
      await this.require([0]);
      dlog("Session: DJ connected");

      // Iterate through competitions in order
      for (const competition of this.competitions) {
        // Register all judges for this competition (can be undefined/disconnected)
        competition.rubric.judges.forEach((j) => {
          if (!this.clients.has(j.id)) {
            this.clients.set(j.id, undefined);
          }
        });

        // Wait for all required clients to connect
        await this.requireAllClients();

        // Announce competition start
        this.competitionStart(competition);

        // Process each competitor sequentially
        for (
          const [position, competitor] of competition.competitors.entries()
        ) {
          try {
            // Performance phase
            const performanceCompleted = await this.performPhase(
              competition,
              position,
            );

            // Only score if performance was completed (not skipped)
            if (performanceCompleted) {
              await this.scorePhase(competition);
            } else {
              console.log(
                `Competitor at position ${position} skipped, no scoring`,
              );
            }
          } catch (err) {
            console.error("Error during competitor", {
              competitionId: competition.id,
              competitorId: competitor.id,
              position,
              err,
            });
          } finally {
            // Clear scores for next competitor
            this.submittedScores.clear();
          }
        }
      }

      console.log(`Session ${this.id} completed successfully`);
    } catch (err) {
      console.error(`Session ${this.id} error:`, err);
      throw err;
    } finally {
      this.reset();
      console.log(`Session ${this.id} reset complete`);
    }
  }

  /**
   * Reset session state after completion
   */
  private reset(): void {
    this.running = false;
    this.currentPhase = "idle";
    this.currentCompetition = null;
    this.currentPosition = -1;
    this.submittedScores.clear();

    // Note: we don't clear clients - they may still be connected for next session
    // If you want to disconnect all clients:
    // this.clients.clear();
  }
}
